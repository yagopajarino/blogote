

<!DOCTYPE html>
<html>
<meta charset="UTF-8">
<style>
@media (prefers-color-scheme: dark) {
    body {
        background-color: #1c1c1c;
        color: white;
    }
    .markdown-body table tr {
        background-color: #1c1c1c;
    }
    .markdown-body table tr:nth-child(2n) {
        background-color: black;
    }
}
</style>



<link rel="alternate" type="application/rss+xml" href="../../../../feed.xml" title="Race Ceremony">



<link rel="stylesheet" type="text/css" href="../../../../css/common-vendor.b8ecfc406ac0b5f77a26.css">
<link rel="stylesheet" type="text/css" href="../../../../css/fretboard.f32f2a8d5293869f0195.css">
<link rel="stylesheet" type="text/css" href="../../../../css/pretty.0ae3265014f89d9850bf.css">
<link rel="stylesheet" type="text/css" href="../../../../css/pretty-vendor.83ac49e057c3eac4fce3.css">
<link rel="stylesheet" type="text/css" href="../../../../css/global.css">
<link rel="stylesheet" type="text/css" href="../../../../css/misc.css">

<script type="text/x-mathjax-config">
<script>
MathJax = {
  tex: {
    inlineMath: [['$', '$'], ['\(', '\)']]
  },
  svg: {
    fontCache: 'global',
  }
};
</script>
<script type="text/javascript" id="MathJax-script" async
  src="../../../../scripts/tex-svg.js">
</script>

<style>
</style>

<div id="doc" class="container-fluid markdown-body comment-enabled" data-hard-breaks="true">

<div id="color-mode-switch">
  <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
    <path stroke-linecap="round" stroke-linejoin="round" d="M12 3v1m0 16v1m9-9h-1M4 12H3m15.364 6.364l-.707-.707M6.343 6.343l-.707-.707m12.728 0l-.707.707M6.343 17.657l-.707.707M16 12a4 4 0 11-8 0 4 4 0 018 0z" />
  </svg>
  <input type="checkbox" id="switch" />
  <label for="switch">Dark Mode Toggle</label>
  <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
    <path stroke-linecap="round" stroke-linejoin="round" d="M20.354 15.354A9 9 0 018.646 3.646 9.003 9.003 0 0012 21a9.003 9.003 0 008.354-5.646z" />
  </svg>
</div>

<script type="text/javascript">
  // Update root html class to set CSS colors
  const toggleDarkMode = () => {
    const root = document.querySelector('html');
    root.classList.toggle('dark');
  }

  // Update local storage value for colorScheme
  const toggleColorScheme = () => {
    const colorScheme = localStorage.getItem('colorScheme');
    if (colorScheme === 'light') localStorage.setItem('colorScheme', 'dark');
    else localStorage.setItem('colorScheme', 'light');
  }

  // Set toggle input handler
  const toggle = document.querySelector('#color-mode-switch input[type="checkbox"]');
  if (toggle) toggle.onclick = () => {
    toggleDarkMode();
    toggleColorScheme();
  }

  // Check for color scheme on init
  const checkColorScheme = () => {
    const colorScheme = localStorage.getItem('colorScheme');
    // Default to light for first view
    if (colorScheme === null || colorScheme === undefined) localStorage.setItem('colorScheme', 'light');
    // If previously saved to dark, toggle switch and update colors
    if (colorScheme === 'dark') {
      toggle.checked = true;
      toggleDarkMode();
    }
  }
  checkColorScheme();
</script>

<meta name="twitter:card" content="summary" />
<meta name="twitter:title" content="Race Ceremony" />
<meta name="twitter:image" content="https://raw.githubusercontent.com/yagopajarino/yagopajarino/refs/heads/main/yago-thumbnail.JPG" />


<br>
<h1 style="margin-bottom:7px"> Race Ceremony </h1>
<small style="float:left; color: #888"> 2023 Aug 16 </small>
<small style="float:right; color: #888"><a href="../../../../index.html">See all posts</a></small>
<br> <br> <br>
<title> Race Ceremony </title>

<p>Vuelvo al blog. El primer cuatrimestre 2023 fue intenso: cambio de
trabajo, facultad, novia 🤗. En este segunda parte del año tengo como
objetivo escribir algo todas las semanas, hay un gran backlog de temas
así que si no hay nuevos posts será exclusivamente por falta de tiempo
🥲</p>
<h2 id="introducción">Introducción</h2>
<p>El año pasado, intentando generar un pedacito de código nuevo todos
los días, me propuse resolver un problema de código por día durante 90
días (al principio fueron 60 pero la emoción lo llevo a 90). Algo de eso
en <a href="https://github.com/yagopajarino/60-days-of-kata">60 days ok
kata</a>.</p>
<p>Codewars es una plataforma que permite a usuarios resolver problemas
de programación, algo así como un dojo de karate, cada problemita se
llama <em>kata</em> y hay de distintos temas y niveles. Si como yo,
usted cree que la práctica hace la perfección, codewars es ÉL lugar para
practicar código y problem solving.</p>
<p>Al final del challenge me había hecho muy amigo de la plataforma,
<em>after all</em> la usaba todos los días. Fue por una de esas que se
me ocurrió contribuir de otro forma: proponiendo nuevos katas en lugar
de resolverlos.</p>
<p>Así fue como, volviendo a algunos ejercicios de la facultad y con un
poco de ingenio y <em>storytelling</em> nació <a
href="https://www.codewars.com/kata/62cecd4e5487c10028996e04/">Race
Ceremony | Codewars</a></p>
<p>La idea de esta post es compartir las dificultades del problema, el
proceso de resolución y una posible solución.</p>
<h2 id="descripción-del-problema">Descripción del problema</h2>
<p>El problema es algo así (en codewars está en inglés pero acá va en
castellano):</p>
<div class="sourceCode" id="cb1"><pre
class="sourceCode txt"><code class="sourceCode default"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>La competencia nacional de karting tiene lugar en tu ciudad y te llamaron para construir el podio de ganadores con los bloques de madera disponibles. Gracias a que vivís en una zona maderera, la cantidad de bloques disponibles es siempre al menos 6.</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>Recordá que un podio de ganadores tiene tres plataformas para las tres primeras posiciones, donde el primer lugar es el más alto y el segundo es más alto que el tercero, además ser ordenan 2do - 1ro - 3ro (Ver imagen)</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>Los organizadores quieren un podio que cumpla:</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>1) El primer lugar tenga altura mínima</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>2) El segundo lugar tenga altura lo más cercana posible al primero, o lo que es igual, que la diferencia de altura entre el primer y segundo lugar sea mínima</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>3) Todas las plataformas tengan altura mayor a cero</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>Your misión, should you choose to accept it, es determinar la cantidad de bloques de madera a utilizar en las plataformas del podio, ordenadas 2do, 1ro, 3ro.</span></code></pre></div>
<h2 id="entendiendo-el-problema">Entendiendo el problema</h2>
<p>Cualquiera que haya visto una carrera habrá visto un podio de
ganadores, la imagen de la portada sirve como aproximación: se tienen
tres plataformas para los primeros tres puestos de la carrera con
distintas alturas dependiendo la posición, obviamente el 1er puesto el
más alto y el 2do más alto que el 3ro.</p>
<p>En el problema nos dicen que las plataformas se van a realizar con
bloques de madera apilados, suponemos que son todos iguales. También nos
dicen que siempre serán a lo sumo 6, ok.</p>
<p>Lo que puede llamar la atención y agregar algo de dificultad son las
✨condiciones✨ que piden los organizadores. Ya no alcanza con agarrar
los bloques y armar cualquier podio que cumpla con las alturas, sino que
piden un podio específico, aquel que cumpla a la vez las tres
condiciones que se mencionan.</p>
<p>Acá es donde sirve arrancar a armar ejemplos para ver qué es lo que
se pide e intentar encontrar un algoritmo para resolverlo.</p>
<p>Imaginemos que tenemos 6 bloques, podríamos hacer un podío que tenga
5 bloques para el 1ro, uno para el 2do y ninguno para el 3ro</p>
<p><img src="../../../../images/podio1.jpeg" /> Con 6 bloques sin
restricciones se puede armar un podio 1,5,0</p>
<p>Sin emgargo, se ve facilmente que este podio no cumple con la última
condición: todas las posiciones tienen que tener altura mayor a
cero.</p>
<p>Podemos solucionarlo sacando un bloque de 1ro y asignandolo a 3ro.
Sin embargo es fácil ver que esto rompe las alturas porque 2do y 3ro
quedarían ambos con altura 1. Hay que sacar uno más de 1ro y agregarlo a
2do.</p>
<p><img src="../../../../images/podio3.jpeg" /></p>
<p>Pasando un bloque de 1ro a 3ro rompe las alturas (y deja una forma
poco amigable)</p>
<p><img src="../../../../images/podio2.jpeg" /></p>
<p>Pasando un bloque más de 1ro a 2do queda como necesitamos</p>
<p>Al finalizar estos dos movimientos, queda un podio con alturas 2,3,1
que cumple las tres condiciones.</p>
<p>A medida que se agregan bloques, deja de ser tan claro como
dividirlos para cumplir con las tres condiciones.</p>
<p>Veamos por ejemplo el caso de 10 bloques. Podriamos armar un podio
que tenga alturas 2,7,1 que cumple las condiciones de alturas para las
posiciones y que todas son mayores a 0.</p>
<p>Sin embargo también nos piden que la altura del 1er puesto sea mínima
y que la diferencia de altura entre 1ro y 2do también sea mínima.</p>
<p>La cosa ahora es ver como podemos chequear que una altura es mínima,
antes podíamos ver el dibujo y darnos cuenta si cumplía las condiciones,
ahora ya no es posible.</p>
<p>Altura mínima, cuando nos dicen que algo es mínimo también nos dicen
que cualquier otra cosa es más grande que ese mínimo. Entonces para
probar que la altura del primer puesto es mínima debemos probar que no
existe ningún otro podio que tenga altura menor.</p>
<p>Volviendo a los 10 bloques, si encontramos algún podio que tenga
altura de primer lugar menor a 7 podremos decir que 7 no es la altura
mínima. Si por ejemplo pasamos un bloque de 1ro a 2do, nos queda 3,6,1.
Si ahora pasamos uno de 1ro a 3ro nos queda 3,5,2 y ya no podemos seguir
cambiando bloques. 3,5,2 parece un buen candidato a cumplir con las tres
condiciones.</p>
<p>Parece que la altura no puede ser menor a 5, pues dado que tenemos 10
bloques, si dividimos los 10 bloques en 3 nos queda 3,33 bloques y si
queremos que el 1er puesto sea más grande que los otros dos
necesariamente debemos sumar dos bloques a esa primera división.</p>
<p>Queda verificar la segunda condición, que la diferencia de altura
entre 1ro y 2do sea mínima. Igual que antes, vemos si no existe alguna
combinación que logre reducir esta diferencia.</p>
<p>Volvamos al momento en que teníamos 3,6,1. Si volvemos a mover un
bloque de 1ro a 2do nos queda 4,5,1</p>
<p><img src="../../../../images/podio4.jpeg" /></p>
<p>En este caso, la altura de 1ro sigue siendo 5 (mínima), y se redujo
la diferencia de altura entre 1ro y 2do a un bloque. Esta configuración
cumple con todas las condiciones pedidas.</p>
<p>Todavía no se ve un muy claro un algoritmo que pueda resolver el
problema cumpliendo todas las condiciones.</p>
<h2 id="a-bit-of-álgebra">A bit of álgebra</h2>
<p>Sí, el problema está inspirado en un problema de álgebra que me
tomaron en la facultad. Lo primero que hay que ver es que la cantidad de
bloques no está acotada, puede ser cualquier cosa (incluso números muy
grandes). Cualquier algoritmo que itere sobre la cantidad de bloques
puede ser muy costoso.</p>
<p>Veamos el siguiente algoritmo. Nos dan los bloques y los dividimos en
tres pilas iguales. Tendríamos un podio con las tres plataformas
iguales, no sirve.</p>
<p>Por ejemplo, con 6 bloques, dividimos los bloques en 3 grupos iguales
y nos quedan 3 plataformas con 2 bloques cada una y no sobran bloques.
Para arreglar las alturas, podemos pasar un bloque de 3ro a 1ro y nos
queda la combinación 2,3,1 que es solución de 6 bloques.</p>
<p>Con 7 bloques, nos quedan de nuevo 3 plataformas con 2 bloques cada
una y sobra un bloque. Agregamos el que sobra a 1ro y pasamos uno de 3ro
a 1ro, nos quedaría la combinación 2,4,1.</p>
<p>Con 8 bloques, nos vuelve a quedar 3 plataformas de 2 bloques cada
una y sobran dos bloques. Agregamos uno de los que sobran a 1ro y el
otro a 2do y listo.</p>
<p>Con 9 bloques, armamos tres plataformas de 3 bloques cada una y no
sobran bloques.</p>
<p>En este punto creo no conviene seguir haciendo ejemplos para
convencerse que hay un patrón que se repite, al dividir la cantidad de
bloques por 3 y ver cuantos sobran, estamos generando una <em>clase de
equivalencia</em>. Solo nos importa el resto que sobrevive al dividir la
cantidad de bloques por 3.</p>
<p>Para nuestro algoritmo, tener 6 bloques, 9 o 93 (3*31) es igual
porque en los tres casos el resto al dividirlos por 3 es 0.</p>
<p>Así, vamos a tener tres clases de equivalencia:</p>
<ol type="1">
<li>Todas las cantidades de bloques que al dividirlas por 3 tengan resto
0</li>
<li>Todas las cantidades de bloques que al dividirlas por 3 tengan resto
1</li>
<li>Todas las cantidades de bloques que al dividirlas por 3 tengan resto
2</li>
</ol>
<p>Y lo más importante, cualquier número que nos den siempre va a caer
en una (y solo una) de estas clases.</p>
<h2 id="algoritmo">Algoritmo</h2>
<p>Usando la intuición del paso anterior podemos diseñar el algoritmo.
Lo primero que va a hacer es calcular la división entera de la cantidad
de bloques por 3, como hicimos en los ejemplos. Luego dependiendo el
resto de la división va a tomar uno de los tres posibles caminos.</p>
<div class="sourceCode" id="cb2"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Implementación del algoritmo en C++</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> race_podium<span class="op">(</span><span class="dt">int</span> blocks<span class="op">)</span> <span class="op">{</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span> cociente <span class="op">=</span> floor<span class="op">(</span>blocks <span class="op">/</span> <span class="dv">3</span><span class="op">);</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>    vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> res<span class="op">;</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>blocks <span class="op">==</span> <span class="dv">7</span><span class="op">)</span>          res <span class="op">=</span> <span class="op">{</span>cociente<span class="op">,</span> cociente <span class="op">+</span> <span class="dv">2</span><span class="op">,</span> cociente <span class="op">-</span><span class="dv">1</span><span class="op">};</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>  <span class="cf">else</span> <span class="cf">if</span> <span class="op">(</span>blocks <span class="op">%</span> <span class="dv">3</span> <span class="op">==</span> <span class="dv">0</span><span class="op">)</span> res <span class="op">=</span> <span class="op">{</span>cociente<span class="op">,</span> cociente <span class="op">+</span> <span class="dv">1</span><span class="op">,</span> cociente <span class="op">-</span> <span class="dv">1</span><span class="op">};</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>  <span class="cf">else</span> <span class="cf">if</span> <span class="op">(</span>blocks <span class="op">%</span> <span class="dv">3</span> <span class="op">==</span> <span class="dv">1</span><span class="op">)</span> res <span class="op">=</span> <span class="op">{</span>cociente <span class="op">+</span> <span class="dv">1</span><span class="op">,</span> cociente <span class="op">+</span> <span class="dv">2</span><span class="op">,</span> cociente <span class="op">-</span> <span class="dv">2</span><span class="op">};</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>  <span class="cf">else</span>                      res <span class="op">=</span> <span class="op">{</span>cociente <span class="op">+</span> <span class="dv">1</span><span class="op">,</span> cociente <span class="op">+</span> <span class="dv">2</span><span class="op">,</span> cociente <span class="op">-</span> <span class="dv">1</span><span class="op">};</span></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> res<span class="op">;</span></span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h2 id="conclusiones">Conclusiones</h2>
<p>No me quiero seguir extendiendo, creo que el post ya quedó bastante
largo. Solo quiero dejar la reflexión de lo valioso que es en muchas
ocasiones tener conceptos matemáticos dando vueltas en la mente a la
hora de resolver problemas usando código.</p>
<p>La matemática, bien enseñada, ayuda un montón a la hora de resolver
problemas, de alguna forma moldea la mente para pensar en forma lógica y
algoritmica, encontrar patrones, etc.</p>
<p>En el link a codewars se pueden ver otras soluciones, algunas muy
interesantes :)</p>
 </div> 